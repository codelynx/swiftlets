#!/bin/bash
# build-site - Universal Swiftlets site builder
# Works on macOS and Linux (Ubuntu)

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Script configuration
SCRIPT_NAME=$(basename "$0")
SWIFTLETS_ROOT="$(cd "$(dirname "$0")" && pwd)"

# Flags
VERBOSE=false
FORCE=false
CLEAN=false
WATCH=false

# Platform detection
OS=$(uname -s | tr '[:upper:]' '[:lower:]')
ARCH=$(uname -m)

# Normalize OS names
case "$OS" in
    darwin*) OS="darwin" ;;
    linux*) OS="linux" ;;
    *) echo -e "${RED}Unsupported OS: $OS${NC}"; exit 1 ;;
esac

# Normalize architecture names
case "$ARCH" in
    x86_64) ARCH="x86_64" ;;
    aarch64|arm64) ARCH="arm64" ;;
    *) echo -e "${RED}Unsupported architecture: $ARCH${NC}"; exit 1 ;;
esac

# MD5 command (macOS vs Linux)
if [[ "$OS" == "darwin" ]]; then
    MD5_CMD="md5 -q"
else
    MD5_CMD="md5sum | cut -d' ' -f1"
fi

# Usage function
usage() {
    cat << EOF
Usage: $SCRIPT_NAME <site-root> [options]

Build a Swiftlets site by compiling Swift files from src/ to bin/

Arguments:
  site-root         Path to the site directory (containing src/ and web/)

Options:
  --verbose         Show detailed build output
  --force           Force rebuild all files (ignore timestamps)
  --clean           Remove bin/ and .webbin files (no build)
  --watch           Watch for changes and rebuild (not implemented yet)
  --help            Show this help message

Examples:
  $SCRIPT_NAME sites/examples/swiftlets-site
  $SCRIPT_NAME sites/examples/swiftlets-site --verbose
  $SCRIPT_NAME sites/examples/swiftlets-site --clean
  $SCRIPT_NAME sites/examples/swiftlets-site --force --verbose

Platform: $OS/$ARCH
EOF
}

# Parse arguments
if [ $# -eq 0 ]; then
    usage
    exit 1
fi

SITE_ROOT=""
while [[ $# -gt 0 ]]; do
    case $1 in
        --verbose)
            VERBOSE=true
            shift
            ;;
        --force)
            FORCE=true
            shift
            ;;
        --clean)
            CLEAN=true
            shift
            ;;
        --watch)
            echo -e "${YELLOW}--watch not implemented yet${NC}"
            exit 1
            ;;
        --help|-h)
            usage
            exit 0
            ;;
        -*)
            echo -e "${RED}Unknown option: $1${NC}"
            usage
            exit 1
            ;;
        *)
            if [ -z "$SITE_ROOT" ]; then
                SITE_ROOT="$1"
            else
                echo -e "${RED}Multiple site roots specified${NC}"
                usage
                exit 1
            fi
            shift
            ;;
    esac
done

# Validate site root
if [ -z "$SITE_ROOT" ]; then
    echo -e "${RED}Site root not specified${NC}"
    usage
    exit 1
fi

# Convert to absolute path
SITE_ROOT=$(cd "$SITE_ROOT" 2>/dev/null && pwd || echo "$SITE_ROOT")

# Check if site root exists
if [ ! -d "$SITE_ROOT" ]; then
    echo -e "${RED}Site root does not exist: $SITE_ROOT${NC}"
    exit 1
fi

# Check for src directory
if [ ! -d "$SITE_ROOT/src" ]; then
    echo -e "${RED}No src/ directory found in: $SITE_ROOT${NC}"
    exit 1
fi

# Clean function
clean_site() {
    echo -e "${YELLOW}Cleaning site: $SITE_ROOT${NC}"
    
    # Remove bin directory
    if [ -d "$SITE_ROOT/bin" ]; then
        rm -rf "$SITE_ROOT/bin"
        echo -e "  ${GREEN}âœ“${NC} Removed bin/"
    fi
    
    # Remove .webbin files
    local webbin_count=$(find "$SITE_ROOT/web" -name "*.webbin" 2>/dev/null | wc -l | tr -d ' ')
    if [ "$webbin_count" -gt 0 ]; then
        find "$SITE_ROOT/web" -name "*.webbin" -delete
        echo -e "  ${GREEN}âœ“${NC} Removed $webbin_count .webbin files"
    fi
    
    echo -e "${GREEN}Clean complete!${NC}"
}

# If clean flag is set, clean and check if we should continue
if [ "$CLEAN" = true ]; then
    clean_site
    # If only cleaning, exit
    if [ "$FORCE" = false ] && [ "$VERBOSE" = false ]; then
        exit 0
    fi
fi

# Build function
build_site() {
    echo -e "${YELLOW}Building site: $SITE_ROOT${NC}"
    echo -e "Platform: ${BLUE}$OS/$ARCH${NC}"
    
    # Create directories
    mkdir -p "$SITE_ROOT/bin"
    mkdir -p "$SITE_ROOT/.build/temp"
    
    # Count Swift files
    local total_files=$(find "$SITE_ROOT/src" -name "*.swift" -type f | wc -l)
    
    echo -e "Found ${BLUE}$total_files${NC} Swift files"
    
    if [ "$total_files" -eq 0 ]; then
        echo -e "${RED}Error: No Swift files found in $SITE_ROOT/src${NC}"
        exit 1
    fi
    
    if [ "$VERBOSE" = true ]; then
        echo -e "Swift files to process:"
        find "$SITE_ROOT/src" -name "*.swift" -type f | sort | sed 's/^/  /'
    fi
    echo
    
    # Check for Components.swift
    local components_file=""
    if [ -f "$SITE_ROOT/src/Components.swift" ]; then
        components_file="$SITE_ROOT/src/Components.swift"
        [ "$VERBOSE" = true ] && echo -e "Found shared components: ${BLUE}Components.swift${NC}"
    fi
    
    # Framework sources
    local framework_sources="$SWIFTLETS_ROOT/Sources/Swiftlets/Core/*.swift \
        $SWIFTLETS_ROOT/Sources/Swiftlets/HTML/Core/*.swift \
        $SWIFTLETS_ROOT/Sources/Swiftlets/HTML/Elements/*.swift \
        $SWIFTLETS_ROOT/Sources/Swiftlets/HTML/Helpers/*.swift \
        $SWIFTLETS_ROOT/Sources/Swiftlets/HTML/Layout/*.swift \
        $SWIFTLETS_ROOT/Sources/Swiftlets/HTML/Modifiers/*.swift \
        $SWIFTLETS_ROOT/Sources/Swiftlets/HTML/Builders/*.swift"
    
    # Build each file
    local built=0
    local skipped=0
    local failed=0
    
    # Process files directly without subshell
    while IFS= read -r file; do
        # Skip Components.swift
        if [[ "$file" == *"Components.swift" ]]; then
            continue
        fi
        
        # Calculate paths
        local relative=${file#$SITE_ROOT/src/}
        local output="$SITE_ROOT/bin/${relative%.swift}"
        local webbin="$SITE_ROOT/web/${relative%.swift}.webbin"
        local outdir=$(dirname "$output")
        local webbindir=$(dirname "$webbin")
        
        # Create output directory
        mkdir -p "$outdir" 2>/dev/null || true
        mkdir -p "$webbindir" 2>/dev/null || true
        
        # Check if rebuild needed
        local need_build=0
        
        if [ "$FORCE" = true ]; then
            need_build=1
            [ "$VERBOSE" = true ] && echo -e "  ${YELLOW}âš¡${NC} Force rebuilding: $relative"
        elif [ ! -f "$output" ]; then
            need_build=1
            [ "$VERBOSE" = true ] && echo -e "  ${YELLOW}ðŸ†•${NC} New file: $relative"
        else
            # Check timestamps
            if [ "$file" -nt "$output" ]; then
                need_build=1
                [ "$VERBOSE" = true ] && echo -e "  ${YELLOW}ðŸ“${NC} Source changed: $relative"
            elif [ -n "$components_file" ] && [ "$components_file" -nt "$output" ]; then
                need_build=1
                [ "$VERBOSE" = true ] && echo -e "  ${YELLOW}ðŸ”§${NC} Components changed: $relative"
            else
                # Check framework files (only check first file of each directory for performance)
                local framework_dirs=(
                    "$SWIFTLETS_ROOT/Sources/Swiftlets/Core"
                    "$SWIFTLETS_ROOT/Sources/Swiftlets/HTML/Core"
                    "$SWIFTLETS_ROOT/Sources/Swiftlets/HTML/Elements"
                    "$SWIFTLETS_ROOT/Sources/Swiftlets/HTML/Helpers"
                    "$SWIFTLETS_ROOT/Sources/Swiftlets/HTML/Layout"
                    "$SWIFTLETS_ROOT/Sources/Swiftlets/HTML/Modifiers"
                    "$SWIFTLETS_ROOT/Sources/Swiftlets/HTML/Builders"
                )
                
                for dir in "${framework_dirs[@]}"; do
                    local newest_file=$(find "$dir" -name "*.swift" -type f -print0 2>/dev/null | xargs -0 ls -t 2>/dev/null | head -1)
                    if [ -n "$newest_file" ] && [ -f "$newest_file" ] && [ "$newest_file" -nt "$output" ]; then
                        need_build=1
                        [ "$VERBOSE" = true ] && echo -e "  ${YELLOW}ðŸ“¦${NC} Framework changed: $relative"
                        break
                    fi
                done
            fi
        fi
        
        if [ $need_build -eq 1 ]; then
            echo -e "  Building ${BLUE}$relative${NC}"
            
            # Prepare temp file
            local temp_file="$SITE_ROOT/.build/temp/$(basename $file)"
            
            # Remove import Swiftlets and fix request usage
            sed -e '/^import Swiftlets$/d' \
                -e 's/let request = try/let _ = try/' \
                "$file" > "$temp_file"
            
            # Build command
            local build_cmd="swiftc -parse-as-library \
                -module-name Swiftlets \
                $framework_sources"
            
            # Add components if exists
            if [ -n "$components_file" ]; then
                build_cmd="$build_cmd $components_file"
            fi
            
            # Add the temp file and output
            build_cmd="$build_cmd $temp_file -o $output"
            
            # Execute build
            if [ "$VERBOSE" = true ]; then
                echo -e "    ${YELLOW}$build_cmd${NC}"
            fi
            
            # Capture output and errors
            local build_output
            build_output=$(eval $build_cmd 2>&1)
            local build_status=$?
            
            if [ $build_status -eq 0 ]; then
                echo -e "    ${GREEN}âœ“ Success${NC}"
                
                # Generate MD5 and create webbin
                if [ -f "$output" ]; then
                    local md5
                    if [[ "$OS" == "darwin" ]]; then
                        md5=$(md5 -q "$output")
                    else
                        md5=$(md5sum "$output" | cut -d' ' -f1)
                    fi
                    echo "$md5" > "$webbin"
                    [ "$VERBOSE" = true ] && echo -e "    ${GREEN}âœ“ Created webbin${NC}: $webbin"
                fi
                
                ((built++))
            else
                echo -e "    ${RED}âœ— Failed${NC}"
                if [ -n "$build_output" ]; then
                    echo -e "    ${RED}Error output:${NC}"
                    echo "$build_output" | sed 's/^/        /'
                fi
                ((failed++))
                rm -rf "$SITE_ROOT/.build/temp"
                exit 1
            fi
        else
            [ "$VERBOSE" = true ] && echo -e "  ${GREEN}âœ“${NC} Up to date: $relative"
            ((skipped++))
        fi
    done < <(find "$SITE_ROOT/src" -name "*.swift" -type f | sort)
    
    # Cleanup
    rm -rf "$SITE_ROOT/.build/temp"
    
    # Summary
    echo
    echo -e "${GREEN}Build complete!${NC}"
    echo -e "  Built: ${GREEN}$built${NC}"
    echo -e "  Skipped: ${BLUE}$skipped${NC}"
    if [ $failed -gt 0 ]; then
        echo -e "  Failed: ${RED}$failed${NC}"
    fi
}

# Main execution
build_site